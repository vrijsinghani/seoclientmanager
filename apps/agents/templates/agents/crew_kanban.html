{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Crew Kanban {% endblock %}
{% block extrastyle %}
{{ block.super }}

<link rel="stylesheet" type="text/css" href="{% static 'agents/css/crew_kanban.css' %}?v=29" crossorigin="anonymous"/>
{% endblock extrastyle %}

{% block content %}
{% csrf_token %}



<div class="container-fluid py-4">
    <!-- Header Card -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-body">
                    <div class="d-flex justify-content-between align-items-start">
                        <!-- Left side with crew info -->
                        <div class="d-flex">
                            <div class="me-3">
                                <div class="avatar avatar-xl position-relative">
                                    <img src="{% static 'assets/img/team-1.jpg' %}" alt="profile_image" class="w-100 border-radius-lg shadow-sm">
                                </div>
                            </div>
                            <div>
                                <h5 class="mb-1">{{ crew.name }}</h5>
                                <p class="mb-0 font-weight-bold text-sm">Execution #{{ execution.id }}</p>
                                <p class="mb-0 text-sm">Started: {{ execution.created_at|date:"Y-m-d H:i:s" }}</p>
                                <p class="mb-0 text-sm">Client: {{client.name}} - {{client.website_url}}</p>
                            </div>
                        </div>
                        
                        <!-- Right side with buttons -->
                        <div class="d-flex gap-2">
                            <button id="cancelExecutionBtn" class="btn btn-danger" style="display: none;">
                                <i class="fas fa-stop-circle me-2"></i>Cancel Execution
                            </button>
                            <button class="btn btn-primary" onclick="showStartExecutionModal()">
                                <i class="fas fa-play me-2"></i>Start Crew Execution
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
  
    <!-- Tasks Section -->
    <div class="row">
      <div class="col-12">
        <div class="card">
          <div class="card-header pb-0">
            <div class="d-flex align-items-center">
              <h6 class="mb-0">Tasks</h6>
              <span id="execution-number" class="text-sm ms-2"></span>
            </div>
          </div>
          <div class="card-body">
            <div class="kanban-container" id="kanban-tasks">
              {% for task in tasks %}
            <!-- Task Board -->
            <div class="kanban-board" data-task-id="{{ task.id }}">
              <header class="kanban-board-header rounded-top p-3">
                <div class="text-white">
                  <div class="task-description" data-bs-toggle="collapse" 
                       href="#taskDesc{{ task.id }}" role="button" 
                       aria-expanded="false" aria-controls="taskDesc{{ task.id }}">
                    {{ task.name|truncatechars:200 }}
                  </div>
                  <div class="collapse" id="taskDesc{{ task.id }}">
                    <div class="text-white-50 mt-2">
                      {{ task.name }}
                    </div>
                  </div>
                </div>
              </header>
              <div class="kanban-drag bg-white rounded-bottom border border-top-0">
                <!-- Task items will be dynamically added here -->
              </div>
            </div>
            {% endfor %}
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Start Execution Modal -->
<div class="modal fade" id="startExecutionModal" tabindex="-1" role="dialog" aria-labelledby="startExecutionModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="startExecutionModalLabel">Start New Execution</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p>Are you sure you want to start a new execution for this crew?</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" onclick="startExecution()">Start Execution</button>
      </div>
    </div>
  </div>
</div>

<!-- Human Input Modal -->
<div class="modal fade" id="humanInputModal" tabindex="-1" role="dialog" aria-labelledby="humanInputModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="humanInputModalLabel">Provide Human Input</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="humanInputText">Input</label>
          <textarea class="form-control" id="humanInputText" rows="3"></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" onclick="submitHumanInput()">Submit</button>
      </div>
    </div>
  </div>
</div>
<!-- Modal for expanded content -->
<!-- Details Modal -->
<div class="modal fade" id="detailsModal" tabindex="-1" aria-labelledby="detailsModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="detailsModalLabel">Stage Details</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="row">
                    <div class="col-md-6">
                        <h6>Basic Information</h6>
                        <dl class="row">
                            <dt class="col-sm-4">Status</dt>
                            <dd class="col-sm-8" id="modalStatus"></dd>
                            <dt class="col-sm-4">Stage Type</dt>
                            <dd class="col-sm-8" id="modalStageType"></dd>
                            <dt class="col-sm-4">Agent</dt>
                            <dd class="col-sm-8" id="modalAgent"></dd>
                        </dl>
                    </div>
                    <div class="col-md-6">
                        <h6>Metadata</h6>
                        <pre class="bg-light p-2 rounded" id="modalMetadata"></pre>
                    </div>
                </div>
                <div class="row mt-3">
                    <div class="col-12">
                        <h6>Content</h6>
                        <div id="modalContent"></div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

{% endblock content %}

{% block extra_js %}
{{ block.super }}
<!-- jKanban -->
<script src="{% static 'assets/js/plugins/jkanban/jkanban.min.js' %}"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/13.0.1/markdown-it.min.js"></script>
<script>
    // Initialize crew and client IDs from Django template
    const crewId = {{ crew.id }};
    const clientId = {% if client %}{{ client.id }}{% else %}null{% endif %};
    
    // WebSocket setup
    const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
    let socket = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    let reconnectDelay = 1000; // Initial reconnect delay
    
    async function fetchActiveExecutions() {
        try {
            const response = await fetch(`/agents/crew/${crewId}/active-executions/`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            
            // Update cancel button based on active executions
            const hasActiveExecution = data.executions && data.executions.length > 0;
            const activeExecutionId = hasActiveExecution ? data.executions[0].execution_id : null;
            updateCancelButton(hasActiveExecution, activeExecutionId);
            
            // Clear boards first
            document.querySelectorAll('.kanban-drag').forEach(board => {
                board.innerHTML = '';
            });
            
            // Repopulate with active executions
            data.executions.forEach(execution => {
                updateKanbanBoard({
                    execution_id: execution.execution_id,
                    task_id: execution.task_id,
                    name: execution.name,
                    status: execution.status,
                    stages: execution.stages
                });
            });
            
            return data;
        } catch (error) {
            console.error('Error fetching active executions:', error);
            return null;
        }
    }

    function connectWebSocket() {
        if (socket && socket.readyState === WebSocket.OPEN) {
            console.log('WebSocket already connected');
            return;
        }
        
        // Close existing socket if it exists
        if (socket) {
            socket.close();
        }

        // Clear all kanban boards
        document.querySelectorAll('.kanban-drag').forEach(board => {
            board.innerHTML = '';
        });
        
        try {
            socket = new WebSocket(
                `${wsScheme}://${window.location.host}/ws/crew/${crewId}/kanban/`
            );
            
            socket.onopen = function(e) {
                console.log('WebSocket connection established');
                // Fetch active executions when connection is established
                fetchActiveExecutions();
            };

            socket.onmessage = function(e) {
                try {
                    const data = JSON.parse(e.data);
                    
                    if (data.type === 'pong') {
                        lastPongTime = Date.now(); // Track last pong time
                        return;
                    }
                    
                    if (data.type === 'error') {
                        console.error('Server error:', data.message);
                        return;
                    }
                    
                    // Handle different message types
                    switch (data.type) {
                        case 'execution_update':
                            updateKanbanBoard(data);
                            break;
                        case 'agent_step':
                            updateAgentProgress(data);
                            break;
                        case 'task_complete':
                            handleTaskComplete(data);
                            break;
                        case 'human_input_request':
                            handleHumanInputRequest(data);
                            break;
                        case 'execution_status_update':
                            handleWebSocketMessage(data);
                            break;
                        default:
                            console.log('Unknown message type:', data.type);
                    }
                } catch (error) {
                    console.error('Error processing WebSocket message:', error);
                }
            };

            socket.onclose = function(e) {
                console.log('WebSocket connection closed', e.code, e.reason);
                stopPingInterval();
                
                // Don't reconnect if closed normally
                if (e.code === 1000 || e.code === 1001) {
                    console.log('WebSocket closed normally');
                    return;
                }
                
                // Attempt to reconnect if not at max attempts
                if (reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
                    
                    // Exponential backoff with jitter
                    reconnectDelay = Math.min(reconnectDelay * 2, 30000);
                    const jitter = Math.random() * 1000;
                    setTimeout(connectWebSocket, reconnectDelay + jitter);
                } else {
                    console.error('Max reconnection attempts reached');
                }
            };

            socket.onerror = function(e) {
                console.error('WebSocket error:', e);
                // Let onclose handle reconnection
            };
            
        } catch (error) {
            console.error('Error creating WebSocket:', error);
            // Attempt to reconnect on connection error
            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                setTimeout(connectWebSocket, reconnectDelay);
            }
        }
    }
    
    // Ping interval to keep connection alive
    let pingInterval;
    let lastPongTime = Date.now();
    
    function startPingInterval() {
        stopPingInterval(); // Clear any existing interval
        
        // Send ping every 15 seconds
        pingInterval = setInterval(() => {
            if (socket && socket.readyState === WebSocket.OPEN) {
                // Check if we haven't received a pong in 45 seconds
                if (Date.now() - lastPongTime > 45000) {
                    console.log('No pong received for 45 seconds, reconnecting...');
                    socket.close();
                    connectWebSocket();
                    return;
                }
                
                socket.send(JSON.stringify({ type: 'ping' }));
            }
        }, 15000);
    }
    
    function stopPingInterval() {
        if (pingInterval) {
            clearInterval(pingInterval);
            pingInterval = null;
        }
    }
    
    // Initial connection
    connectWebSocket();
    
    // Clean up on page unload
    window.addEventListener('beforeunload', () => {
        stopPingInterval();
        if (socket) {
            socket.close();
        }
    });

    const md = window.markdownit();
    
    function showContentModal(stageId, content) {
        try {
            const modalContent = document.getElementById('modalContent');
            if (!modalContent) {
                console.error('Modal content element not found');
                return;
            }
            modalContent.innerHTML = md.render(content);
            const modal = new bootstrap.Modal(document.getElementById('contentModal'));
            modal.show();
        } catch (error) {
            console.error('Error showing modal:', error);
        }
    }

    // Track the last updated task ID
    let lastUpdatedTaskId = null;

    function updateKanbanBoard(data) {
        console.log('Updating kanban board:', data);
        
        // Only proceed if we have an execution_id
        if (!data.execution_id) {
            console.log('No execution_id provided, skipping update');
            return;
        }
        
        // Update cancel button based on execution status
        if (data.execution_id && data.status) {
            const isActive = ['PENDING', 'RUNNING'].includes(data.status.toUpperCase());
            updateCancelButton(isActive, isActive ? data.execution_id : null);
        }
        
        // Update execution number in header
        const executionSpan = document.getElementById('execution-number');
        if (executionSpan) {
            executionSpan.textContent = ` - Execution #${data.execution_id}`;
        }

        // Get CrewAI task ID for kanban board placement
        let crewaiTaskId = data.crewai_task_id;
        
        // Handle system updates (like PENDING, RUNNING, COMPLETED) or null crewai_task_id
        if (!crewaiTaskId || (typeof crewaiTaskId === 'string' && crewaiTaskId.includes('-'))) {
            // If we have a last updated task ID, use that
            if (lastUpdatedTaskId) {
                crewaiTaskId = lastUpdatedTaskId;
            } else {
                // If no last updated task ID, use the first task board
                const firstTaskBoard = document.querySelector('.kanban-board');
                if (firstTaskBoard) {
                    addUpdateToBoard(firstTaskBoard, data);
                    return;
                } else {
                    console.log('No task boards found for system update');
                    return;
                }
            }
        } else if (typeof crewaiTaskId === 'number' || (typeof crewaiTaskId === 'string' && !crewaiTaskId.includes('-'))) {
            // This is a regular task update (number or non-hyphenated string)
            // Update the last updated task ID
            lastUpdatedTaskId = crewaiTaskId;
        }

        // Find the task board for this specific task
        const taskBoard = document.querySelector(`[data-task-id="${crewaiTaskId}"]`);
        if (!taskBoard) {
            console.log('Task board not found for CrewAI task ID:', crewaiTaskId);
            // Fallback to first task board if no specific board found
            const firstTaskBoard = document.querySelector('.kanban-board');
            if (firstTaskBoard) {
                addUpdateToBoard(firstTaskBoard, data);
            }
            return;
        }

        // Add the update to the board
        addUpdateToBoard(taskBoard, data);

        // Update all cards in this task board if status is COMPLETED
        const status = data.status?.toUpperCase();
        if (status === 'COMPLETED') {
            const cards = taskBoard.querySelectorAll('.kanban-item');
            cards.forEach(card => {
                const header = card.querySelector('.card-header');
                if (header) {
                    header.className = 'card-header bg-gradient-success text-white p-2';
                }
            });
        }
    }


    function addUpdateToBoard(taskBoard, data) {
    const kanbanDrag = taskBoard.querySelector('.kanban-drag');
    if (!kanbanDrag) return;

        const stageId = `${data.stage?.stage_type || 'status'}-${Date.now()}`;
        const content = data.stage?.content || '';
        const truncatedContent = content.length > 200 ? content.substring(0, 200) + '...' : content;
        
        const stageHtml = `
            <div class="stage-item" data-execution-id="${data.execution_id}" data-stage-id="${stageId}">
                <div class="d-flex justify-content-between align-items-center">
                    <div class="d-flex align-items-center gap-2">
                        <span class="stage-status status-${(data.stage?.status || data.status)?.toLowerCase()}">
                            ${data.stage?.status || data.status}
                        </span>
                    </div>
                    <div class="d-flex align-items-center gap-2">
                        <button class="btn btn-link btn-sm p-0 text-muted" 
                                onclick="showDetailsModal('${stageId}', ${JSON.stringify(data).replace(/"/g, '&quot;')})">
                            <i class="fas fa-info-circle"></i>
                        </button>
                        ${data.stage?.artifacts ? `
                            <button class="btn btn-link btn-sm p-0 text-muted" 
                                    onclick="downloadArtifacts('${data.execution_id}', '${stageId}')">
                                <i class="fas fa-download"></i>
                            </button>
                        ` : ''}
                        <span class="time-stamp">${new Date().toLocaleTimeString()}</span>
                    </div>
                </div>
                
                <h6 class="stage-title">${data.stage?.title || 'Status Update'}</h6>
                
                <div class="stage-content">
                    ${md.render(truncatedContent)}
                    ${content.length > 200 ? `
                        <button class="toggle-content" 
                                data-bs-toggle="collapse" 
                                data-bs-target="#content-${stageId}" 
                                aria-expanded="false">
                            SHOW MORE
                        </button>
                        <div class="collapse" id="content-${stageId}">
                            <div class="pt-2">
                                ${md.render(content)}
                            </div>
                        </div>
                    ` : ''}
                </div>
                
                ${data.stage?.agent ? `
                    <div class="stage-agent">
                        <i class="fas fa-${data.stage.type === 'message' ? 'comment' : 'robot'}"></i>
                        ${data.stage.agent}
                    </div>
                ` : ''}
            </div>`;

        kanbanDrag.insertAdjacentHTML('beforeend', stageHtml);
    }


    function updateAgentProgress(data) {
        console.log('Updating agent progress:', data);
        const execution = document.querySelector(`[data-execution-id="${data.execution_id}"]`);
        if (!execution) return;

        const stageContainer = execution.querySelector('.card-body');
        const agentSection = stageContainer.querySelector('.agent-progress') || 
            stageContainer.insertAdjacentHTML('beforeend', '<div class="agent-progress mt-3"></div>');

        const progressHtml = `
            <div class="alert alert-info mb-2">
                <strong>${data.agent || 'Agent'}</strong>: ${data.content}
            </div>
        `;
        
        if (agentSection.children.length > 5) {
            agentSection.removeChild(agentSection.firstChild);
        }
        agentSection.insertAdjacentHTML('beforeend', progressHtml);
    }

    function handleTaskComplete(data) {
        console.log('Task completed:', data);
        const execution = document.querySelector(`[data-execution-id="${data.execution_id}"]`);
        if (!execution) return;

        // Show completion message
        const stageContainer = execution.querySelector('.card-body');
        const completionHtml = `
            <div class="alert alert-success mb-0">
                <strong>Task Complete!</strong> ${data.message || ''}
            </div>
        `;
        stageContainer.insertAdjacentHTML('beforeend', completionHtml);
    }

    function handleHumanInputRequest(data) {
        console.log('Human input requested:', data);
        showInputModal(data.execution_id);
    }

    function getCsrfToken() {
        const token = document.querySelector('[name=csrfmiddlewaretoken]');
        if (!token) {
            console.error('CSRF token not found');
            return '';
        }
        return token.value;
    }

    function showStartExecutionModal() {
        const modal = document.getElementById('startExecutionModal');
        const bsModal = new bootstrap.Modal(modal);
        bsModal.show();
    }

    function startExecution() {
        const csrfToken = getCsrfToken();
        
        if (!csrfToken) {
            alert('Error: CSRF token not found. Please refresh the page.');
            return;
        }

        if (!clientId) {
            alert('Error: No client selected. Please select a client first.');
            return;
        }

        // Clear all kanban boards
        const kanbanBoards = document.querySelectorAll('.kanban-board');
        kanbanBoards.forEach(board => {
            const kanbanDrag = board.querySelector('.kanban-drag');
            if (kanbanDrag) {
                kanbanDrag.innerHTML = '';
            }
        });

        // Reset execution number
        const executionSpan = document.getElementById('execution-number');
        if (executionSpan) {
            executionSpan.textContent = '';
        }

        fetch(`/agents/crew/${crewId}/start-execution/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({
                client_id: clientId
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                bootstrap.Modal.getInstance(document.getElementById('startExecutionModal')).hide();
                // No need to reload, WebSocket will handle updates
            } else {
                alert('Error starting execution: ' + data.message);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error starting execution');
        });
    }

    function showInputModal(executionId) {
        const modal = new bootstrap.Modal(document.getElementById('humanInputModal'));
        document.getElementById('humanInputModal').dataset.executionId = executionId;
        modal.show();
    }

    function submitHumanInput() {
        const executionId = document.getElementById('humanInputModal').dataset.executionId;
        const inputText = document.getElementById('humanInputText').value;
        const csrfToken = getCsrfToken();
        
        if (!csrfToken) {
            alert('Error: CSRF token not found. Please refresh the page.');
            return;
        }
        
        fetch(`/agents/crew/execution/${executionId}/input/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({ input: inputText })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                bootstrap.Modal.getInstance(document.getElementById('humanInputModal')).hide();
                document.getElementById('humanInputText').value = '';
            } else {
                alert('Error submitting input');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error submitting input');
        });
    }

    // Add event listener for view full content buttons
    document.addEventListener('click', function(e) {
        if (e.target.matches('.view-full-content')) {
            const stageId = e.target.dataset.stageId;
            const content = decodeURIComponent(e.target.dataset.content);
            showContentModal(stageId, content);
        }
    });

    function toggleContent(element) {
        const container = element.closest('p');
        const collapsedContent = container.querySelector('.collapsed-content');
        const expandedContent = container.querySelector('.expanded-content');
        
        if (collapsedContent.classList.contains('d-none')) {
            // Collapse
            collapsedContent.classList.remove('d-none');
            expandedContent.classList.add('d-none');
            element.classList.remove('expanded');
        } else {
            // Expand
            collapsedContent.classList.add('d-none');
            expandedContent.classList.remove('d-none');
            element.classList.add('expanded');
        }
    }

    // Function to show/hide cancel button based on execution status
    function updateCancelButton(hasActiveExecution, executionId) {
        console.log('updateCancelButton:', { hasActiveExecution, executionId });  // Debug log
        const cancelBtn = document.getElementById('cancelExecutionBtn');
        if (!cancelBtn) {
            console.error('Cancel button not found');  // Debug log
            return;
        }
        cancelBtn.style.display = hasActiveExecution ? 'block' : 'none';
        if (hasActiveExecution) {
            cancelBtn.setAttribute('data-execution-id', executionId);
        } else {
            cancelBtn.removeAttribute('data-execution-id');
        }
    }

    // Add cancel execution functionality
    async function cancelExecution(executionId) {
        try {
            const response = await fetch(`/agents/execution/${executionId}/cancel/`, {
                method: 'POST',
                headers: {
                    'X-CSRFToken': getCsrfToken(),
                    'Content-Type': 'application/json',
                },
            });

            if (!response.ok) {
                throw new Error('Failed to cancel execution');
            }
            
            updateCancelButton(false);
        } catch (error) {
            console.error('Error cancelling execution:', error);
            alert('Failed to cancel execution. Please try again.');
        }
    }

    // Add click handler for cancel button
    document.getElementById('cancelExecutionBtn').addEventListener('click', function() {
        const executionId = this.getAttribute('data-execution-id');
        if (executionId) {
            if (confirm('Are you sure you want to cancel this execution?')) {
                cancelExecution(executionId);
            }
        }
    });

    function handleWebSocketMessage(data) {
        if (data.type === 'execution_status_update' || data.type === 'execution_update') {
            // Update cancel button based on execution status
            const isActive = ['PENDING', 'RUNNING'].includes(data.status.toUpperCase());
            updateCancelButton(isActive, isActive ? data.execution_id : null);
        }
    }

    // Initial fetch of active executions and setup of cancel button
    document.addEventListener('DOMContentLoaded', async function() {
        const data = await fetchActiveExecutions();
        const hasActiveExecution = data && data.executions && data.executions.length > 0;
        const activeExecutionId = hasActiveExecution ? data.executions[0].execution_id : null;
        updateCancelButton(hasActiveExecution, activeExecutionId);
    });
</script>
{% endblock extra_js %}