{% extends "layouts/base.html" %}
{% load static %}

{% block title %} Crew Kanban {% endblock %}

{% block extrastyle %}
{{ block.super }}
<!-- jKanban styles -->
<!-- <link rel="stylesheet" href="{% static 'assets/css/plugins/jkanban/jkanban.min.css' %}"/> -->
<style>
.kanban-container {
  padding: 1.25rem;
  display: flex;
  overflow-x: auto;
}

.kanban-board {
  min-width: 320px;
  max-width: 640px;
  margin: 0 0.9375rem;
}

.kanban-drag {
  min-height: 200px;
  padding: 1.25rem;
}

.kanban-item {
  margin-bottom: 0.9375rem;
}

/* Custom scrollbar for better visibility */
.kanban-container::-webkit-scrollbar {
  height: 0.5rem;
}

.kanban-container::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.1);
}

.kanban-container::-webkit-scrollbar-thumb {
  background: var(--bs-primary);
  border-radius: 0.25rem;
}

.kanban-container::-webkit-scrollbar-thumb:hover {
  background: var(--bs-primary-darker);
}

/* Stage status indicators */
.stage-status {
  display: inline-block;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  margin-right: 5px;
}

.stage-status.pending { background-color: var(--bs-gray); }
.stage-status.in-progress { background-color: var(--bs-primary); }
.stage-status.completed { background-color: var(--bs-success); }
.stage-status.failed { background-color: var(--bs-danger); }

.toggle-content {
  color: var(--bs-primary);
  text-decoration: none;
  margin-left: 0.5rem;
}

.toggle-content:hover {
  color: var(--bs-primary-darker);
}

.toggle-content i {
  transition: transform 0.2s;
}

.toggle-content.expanded i {
  transform: rotate(180deg);
}

.stage-item {
  border: 1px solid #e9ecef;
  border-radius: 0.5rem;
  padding: 1rem;
  margin-bottom: 1rem;
  background-color: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  transition: all 0.3s ease;
}

.stage-item.completed {
  border-left: 4px solid #2dce89;
}

.stage-item.in-progress {
  border-left: 4px solid #11cdef;
}

.stage-status {
  display: inline-block;
  width: 8px;
  height: 8px;
  border-radius: 50%;
  margin-right: 8px;
}

.stage-status.completed {
  background-color: #2dce89;
}

.stage-status.in_progress, .stage-status.running {
  background-color: #11cdef;
}

.stage-status.pending {
  background-color: #fb6340;
}

.stage-status.error {
  background-color: #f5365c;
}

.stages-container {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  padding: 0.5rem;
}
</style>
{% endblock extrastyle %}

{% block extra_css %}
{{ block.super }}
<style>
  .task-description {
    cursor: pointer;
  }
  .task-description:hover {
    opacity: 0.9;
  }
  .task-description::after {
    content: '\f078';  /* FontAwesome chevron-down icon */
    font-family: "Font Awesome 5 Free";
    font-weight: 900;
    margin-left: 0.5rem;
    font-size: 0.75rem;
    transition: transform 0.2s;
  }
  .task-description[aria-expanded="true"]::after {
    transform: rotate(180deg);
  }
</style>
{% endblock extra_css %}

{% block content %}
{% csrf_token %}
<div class="container-fluid py-4">
  <!-- Crew Header -->
  <div class="row mb-4">
    <div class="col-12">
      <div class="card">
        <div class="card-header pb-0">
          <div class="d-flex justify-content-between align-items-center">
            <div>
              <h6>{{ crew.name }}</h6>
              <p class="text-sm mb-0">{{ client.name }} - {{ client.website_url }}</p>
            </div>
            <button class="btn btn-primary" onclick="showStartExecutionModal()">
              <i class="fas fa-play me-2"></i>Start Crew Execution
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Kanban Board -->
  <div class="row">
    <div class="col-12">
      <div class="card">
        <div class="card-header pb-0">
          <h6>Tasks <span id="execution-number"></span></h6>
        </div>
        <div class="card-body">
          <div class="kanban-container" id="kanban-tasks">
            {% for task in tasks %}
            <!-- Task Board -->
            <div class="kanban-board" data-task-id="{{ task.id }}">
              <header class="kanban-board-header bg-gradient-primary rounded-top p-3">
                <div class="text-white">
                  <div class="task-description" data-bs-toggle="collapse" 
                       href="#taskDesc{{ task.id }}" role="button" 
                       aria-expanded="false" aria-controls="taskDesc{{ task.id }}">
                    {{ task.name|truncatechars:200 }}
                  </div>
                  <div class="collapse" id="taskDesc{{ task.id }}">
                    <div class="text-white-50 mt-2">
                      {{ task.name }}
                    </div>
                  </div>
                </div>
              </header>
              <div class="kanban-drag bg-white rounded-bottom border border-top-0">
                <!-- Task items will be dynamically added here -->
              </div>
            </div>
            {% endfor %}
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- Start Execution Modal -->
<div class="modal fade" id="startExecutionModal" tabindex="-1" role="dialog" aria-labelledby="startExecutionModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="startExecutionModalLabel">Start New Execution</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <p>Are you sure you want to start a new execution for this crew?</p>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" onclick="startExecution()">Start Execution</button>
      </div>
    </div>
  </div>
</div>

<!-- Human Input Modal -->
<div class="modal fade" id="humanInputModal" tabindex="-1" role="dialog" aria-labelledby="humanInputModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered" role="document">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="humanInputModalLabel">Provide Human Input</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="humanInputText">Input</label>
          <textarea class="form-control" id="humanInputText" rows="3"></textarea>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-primary" onclick="submitHumanInput()">Submit</button>
      </div>
    </div>
  </div>
</div>
<!-- Modal for expanded content -->
<div class="modal fade" id="contentModal" tabindex="-1" role="dialog" aria-labelledby="contentModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg" role="document">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="contentModalLabel">Content Details</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body" id="modalContent"></div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
{% endblock content %}

{% block extra_js %}
{{ block.super }}
<!-- jKanban -->
<script src="{% static 'assets/js/plugins/jkanban/jkanban.min.js' %}"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/13.0.1/markdown-it.min.js"></script>
<script>
    // Initialize crew and client IDs from Django template
    const crewId = {{ crew.id }};
    const clientId = {% if client %}{{ client.id }}{% else %}null{% endif %};
    
    // WebSocket setup
    const wsScheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
    let socket = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;
    let reconnectDelay = 1000; // Initial reconnect delay
    
    async function fetchActiveExecutions() {
        try {
            const response = await fetch(`/agents/crew/${crewId}/active-executions/`);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            
            // Clear boards first
            document.querySelectorAll('.kanban-drag').forEach(board => {
                board.innerHTML = '';
            });
            
            // Repopulate with active executions
            data.executions.forEach(execution => {
                updateKanbanBoard({
                    execution_id: execution.execution_id,
                    task_id: execution.task_id,
                    name: execution.name,
                    status: execution.status,
                    stages: execution.stages
                });
            });
        } catch (error) {
            console.error('Error fetching active executions:', error);
        }
    }

    function connectWebSocket() {
        if (socket && socket.readyState === WebSocket.OPEN) {
            console.log('WebSocket already connected');
            return;
        }
        
        // Close existing socket if it exists
        if (socket) {
            socket.close();
        }

        // Clear all kanban boards
        document.querySelectorAll('.kanban-drag').forEach(board => {
            board.innerHTML = '';
        });
        
        try {
            socket = new WebSocket(
                `${wsScheme}://${window.location.host}/ws/crew/${crewId}/kanban/`
            );
            
            socket.onopen = function(e) {
                console.log('WebSocket connection established');
                // Fetch active executions when connection is established
                fetchActiveExecutions();
            };

            socket.onmessage = function(e) {
                try {
                    const data = JSON.parse(e.data);
                    
                    if (data.type === 'pong') {
                        lastPongTime = Date.now(); // Track last pong time
                        return;
                    }
                    
                    if (data.type === 'error') {
                        console.error('Server error:', data.message);
                        return;
                    }
                    
                    // Handle different message types
                    switch (data.type) {
                        case 'execution_update':
                            updateKanbanBoard(data);
                            break;
                        case 'agent_step':
                            updateAgentProgress(data);
                            break;
                        case 'task_complete':
                            handleTaskComplete(data);
                            break;
                        case 'human_input_request':
                            handleHumanInputRequest(data);
                            break;
                        default:
                            console.log('Unknown message type:', data.type);
                    }
                } catch (error) {
                    console.error('Error processing WebSocket message:', error);
                }
            };

            socket.onclose = function(e) {
                console.log('WebSocket connection closed', e.code, e.reason);
                stopPingInterval();
                
                // Don't reconnect if closed normally
                if (e.code === 1000 || e.code === 1001) {
                    console.log('WebSocket closed normally');
                    return;
                }
                
                // Attempt to reconnect if not at max attempts
                if (reconnectAttempts < maxReconnectAttempts) {
                    reconnectAttempts++;
                    console.log(`Attempting to reconnect (${reconnectAttempts}/${maxReconnectAttempts})...`);
                    
                    // Exponential backoff with jitter
                    reconnectDelay = Math.min(reconnectDelay * 2, 30000);
                    const jitter = Math.random() * 1000;
                    setTimeout(connectWebSocket, reconnectDelay + jitter);
                } else {
                    console.error('Max reconnection attempts reached');
                }
            };

            socket.onerror = function(e) {
                console.error('WebSocket error:', e);
                // Let onclose handle reconnection
            };
            
        } catch (error) {
            console.error('Error creating WebSocket:', error);
            // Attempt to reconnect on connection error
            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                setTimeout(connectWebSocket, reconnectDelay);
            }
        }
    }
    
    // Ping interval to keep connection alive
    let pingInterval;
    let lastPongTime = Date.now();
    
    function startPingInterval() {
        stopPingInterval(); // Clear any existing interval
        
        // Send ping every 15 seconds
        pingInterval = setInterval(() => {
            if (socket && socket.readyState === WebSocket.OPEN) {
                // Check if we haven't received a pong in 45 seconds
                if (Date.now() - lastPongTime > 45000) {
                    console.log('No pong received for 45 seconds, reconnecting...');
                    socket.close();
                    connectWebSocket();
                    return;
                }
                
                socket.send(JSON.stringify({ type: 'ping' }));
            }
        }, 15000);
    }
    
    function stopPingInterval() {
        if (pingInterval) {
            clearInterval(pingInterval);
            pingInterval = null;
        }
    }
    
    // Initial connection
    connectWebSocket();
    
    // Clean up on page unload
    window.addEventListener('beforeunload', () => {
        stopPingInterval();
        if (socket) {
            socket.close();
        }
    });

    const md = window.markdownit();
    
    function showContentModal(stageId, content) {
        try {
            const modalContent = document.getElementById('modalContent');
            if (!modalContent) {
                console.error('Modal content element not found');
                return;
            }
            modalContent.innerHTML = md.render(content);
            const modal = new bootstrap.Modal(document.getElementById('contentModal'));
            modal.show();
        } catch (error) {
            console.error('Error showing modal:', error);
        }
    }

    // Track the last updated task ID
    let lastUpdatedTaskId = null;

    function updateKanbanBoard(data) {
        console.log('Updating kanban board:', data);
        
        // Only proceed if we have an execution_id
        if (!data.execution_id) {
            console.log('No execution_id provided, skipping update');
            return;
        }
        
        // Update execution number in header
        const executionSpan = document.getElementById('execution-number');
        if (executionSpan) {
            executionSpan.textContent = ` - Execution #${data.execution_id}`;
        }

        // Get CrewAI task ID for kanban board placement
        let crewaiTaskId = data.crewai_task_id;
        
        // Handle system updates (like PENDING, RUNNING, COMPLETED) or null crewai_task_id
        if (!crewaiTaskId || (typeof crewaiTaskId === 'string' && crewaiTaskId.includes('-'))) {
            // If we have a last updated task ID, use that
            if (lastUpdatedTaskId) {
                crewaiTaskId = lastUpdatedTaskId;
            } else {
                // If no last updated task ID, use the first task board
                const firstTaskBoard = document.querySelector('.kanban-board');
                if (firstTaskBoard) {
                    addUpdateToBoard(firstTaskBoard, data);
                    return;
                } else {
                    console.log('No task boards found for system update');
                    return;
                }
            }
        } else if (typeof crewaiTaskId === 'number' || (typeof crewaiTaskId === 'string' && !crewaiTaskId.includes('-'))) {
            // This is a regular task update (number or non-hyphenated string)
            // Update the last updated task ID
            lastUpdatedTaskId = crewaiTaskId;
        }

        // Find the task board for this specific task
        const taskBoard = document.querySelector(`[data-task-id="${crewaiTaskId}"]`);
        if (!taskBoard) {
            console.log('Task board not found for CrewAI task ID:', crewaiTaskId);
            // Fallback to first task board if no specific board found
            const firstTaskBoard = document.querySelector('.kanban-board');
            if (firstTaskBoard) {
                addUpdateToBoard(firstTaskBoard, data);
            }
            return;
        }

        // Add the update to the board
        addUpdateToBoard(taskBoard, data);

        // Update all cards in this task board if status is COMPLETED
        if (data.status === 'COMPLETED') {
            const cards = taskBoard.querySelectorAll('.kanban-item');
            cards.forEach(card => {
                const header = card.querySelector('.card-header');
                if (header) {
                    header.className = 'card-header bg-gradient-success text-white p-2';
                }
            });
        }
    }

    function addUpdateToBoard(taskBoard, data) {
        const kanbanDrag = taskBoard.querySelector('.kanban-drag');
        if (!kanbanDrag) return;

        // Create a unique ID for this stage update
        const stageId = `${data.stage?.stage_type || 'status'}-${Date.now()}`;
        
        // Get the content and create truncated version
        const content = data.stage?.content || '';
        const truncatedContent = content.length > 200 ? content.substring(0, 200) + '...' : content;
        
        // Create the card HTML
        const stageHtml = `
            <div class="kanban-item card" data-execution-id="${data.execution_id}" data-stage-id="${stageId}">
                <div class="card-header bg-gradient-${data.status === 'COMPLETED' ? 'success' : 'info'} text-white p-2">
                    <div class="d-flex justify-content-between align-items-center">
                        <h6 class="mb-0">
                            <span class="stage-status ${data.stage?.status || data.status.toLowerCase()}"></span>
                            ${data.stage?.title || 'Status Update'}
                        </h6>
                        ${data.stage?.stage_type === 'human_input' && !data.stage?.completed ? `
                            <button class="btn btn-sm btn-primary" onclick="showInputModal('${data.execution_id}')">
                                Provide Input
                            </button>
                        ` : ''}
                    </div>
                </div>
                <div class="card-body">
                    <div class="content">
                        ${md.render(truncatedContent)}
                        ${content.length > 200 ? `
                            <div class="mt-2">
                                <button class="btn btn-sm btn-primary view-full-content" 
                                    data-stage-id="${stageId}"
                                    data-content="${encodeURIComponent(content)}">
                                    View Full Content
                                </button>
                                <a href="data:text/markdown;charset=utf-8,${encodeURIComponent(content)}" 
                                  download="content-${stageId}.md" 
                                  class="btn btn-sm btn-secondary">
                                    Download
                                </a>
                            </div>
                        ` : ''}
                    </div>
                </div>
            </div>`;

        kanbanDrag.insertAdjacentHTML('beforeend', stageHtml);
    }

    function updateAgentProgress(data) {
        console.log('Updating agent progress:', data);
        const execution = document.querySelector(`[data-execution-id="${data.execution_id}"]`);
        if (!execution) return;

        const stageContainer = execution.querySelector('.card-body');
        const agentSection = stageContainer.querySelector('.agent-progress') || 
            stageContainer.insertAdjacentHTML('beforeend', '<div class="agent-progress mt-3"></div>');

        const progressHtml = `
            <div class="alert alert-info mb-2">
                <strong>${data.agent || 'Agent'}</strong>: ${data.content}
            </div>
        `;
        
        if (agentSection.children.length > 5) {
            agentSection.removeChild(agentSection.firstChild);
        }
        agentSection.insertAdjacentHTML('beforeend', progressHtml);
    }

    function handleTaskComplete(data) {
        console.log('Task completed:', data);
        const execution = document.querySelector(`[data-execution-id="${data.execution_id}"]`);
        if (!execution) return;

        // Show completion message
        const stageContainer = execution.querySelector('.card-body');
        const completionHtml = `
            <div class="alert alert-success mb-0">
                <strong>Task Complete!</strong> ${data.message || ''}
            </div>
        `;
        stageContainer.insertAdjacentHTML('beforeend', completionHtml);
    }

    function handleHumanInputRequest(data) {
        console.log('Human input requested:', data);
        showInputModal(data.execution_id);
    }

    function getCsrfToken() {
        const token = document.querySelector('[name=csrfmiddlewaretoken]');
        if (!token) {
            console.error('CSRF token not found');
            return '';
        }
        return token.value;
    }

    function showStartExecutionModal() {
        const modal = document.getElementById('startExecutionModal');
        const bsModal = new bootstrap.Modal(modal);
        bsModal.show();
    }

    function startExecution() {
        const csrfToken = getCsrfToken();
        
        if (!csrfToken) {
            alert('Error: CSRF token not found. Please refresh the page.');
            return;
        }

        if (!clientId) {
            alert('Error: No client selected. Please select a client first.');
            return;
        }

        fetch(`/agents/crew/${crewId}/start-execution/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({
                client_id: clientId
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                bootstrap.Modal.getInstance(document.getElementById('startExecutionModal')).hide();
                // No need to reload, WebSocket will handle updates
            } else {
                alert('Error starting execution: ' + data.message);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error starting execution');
        });
    }

    function showInputModal(executionId) {
        const modal = new bootstrap.Modal(document.getElementById('humanInputModal'));
        document.getElementById('humanInputModal').dataset.executionId = executionId;
        modal.show();
    }

    function submitHumanInput() {
        const executionId = document.getElementById('humanInputModal').dataset.executionId;
        const inputText = document.getElementById('humanInputText').value;
        const csrfToken = getCsrfToken();
        
        if (!csrfToken) {
            alert('Error: CSRF token not found. Please refresh the page.');
            return;
        }
        
        fetch(`/agents/crew/execution/${executionId}/input/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({ input: inputText })
        })
        .then(response => response.json())
        .then(data => {
            if (data.status === 'success') {
                bootstrap.Modal.getInstance(document.getElementById('humanInputModal')).hide();
                document.getElementById('humanInputText').value = '';
            } else {
                alert('Error submitting input');
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Error submitting input');
        });
    }

    // Add event listener for view full content buttons
    document.addEventListener('click', function(e) {
        if (e.target.matches('.view-full-content')) {
            const stageId = e.target.dataset.stageId;
            const content = decodeURIComponent(e.target.dataset.content);
            showContentModal(stageId, content);
        }
    });

    function toggleContent(element) {
        const container = element.closest('p');
        const collapsedContent = container.querySelector('.collapsed-content');
        const expandedContent = container.querySelector('.expanded-content');
        
        if (collapsedContent.classList.contains('d-none')) {
            // Collapse
            collapsedContent.classList.remove('d-none');
            expandedContent.classList.add('d-none');
            element.classList.remove('expanded');
        } else {
            // Expand
            collapsedContent.classList.add('d-none');
            expandedContent.classList.remove('d-none');
            element.classList.add('expanded');
        }
    }
</script>
{% endblock extra_js %}